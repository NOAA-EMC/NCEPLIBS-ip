<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NCEPLIBS-ip: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NCEPLIBS-ip
   &#160;<span id="projectnumber">4.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">NCEPLIBS-ip Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md0"></a>
Introduction</h2>
<p>The NCEP general interpolation library (NCEPLIBS-ip) contains Fortran 90 subprograms to be used for interpolating between nearly all grids used at NCEP. The library is particularly efficient when interpolating many fields at one time.</p>
<p>NCEPLIBS-ip supports compilation with the GNU Compiler Collection (gfortran), Intel Classic (ifort), and Intel OneAPI (ifx) compilers. In the case of Intel LLVM, it is recommended to use at least version 2023.2.1 to avoid any number of compiler issues.</p>
<h2><a class="anchor" id="autotoc_md1"></a>
Interpolation</h2>
<p>There are currently six interpolation methods available in the library:</p><ul>
<li>bilinear</li>
<li>bicubic</li>
<li>neighbor</li>
<li>budget</li>
<li>spectral</li>
<li>neighbor-budget</li>
</ul>
<p>Some of the methods have interpolation sub-options. A few methods have restrictions on the type of input or output grids.</p>
<p>Several methods can perform interpolation on fields with bitmaps (i.e. some points on the input grid may be undefined). In this case, the bitmap is interpolated to the output grid. Only valid input points are used to interpolate to valid output points. An output bitmap will also be created to locate invalid data where the output grid extends outside the domain of the input grid.</p>
<p>The driver routines for interpolating scalars and vectors may be found in <a class="el" href="namespaceipolates__mod.html" title="Top-level driver for scalar interpolation interpolation routine ipolates().">ipolates_mod</a>. The interpolation method is chosen via the first argument of these routines (variable IP). Sub-options are set via the IPOPT array.</p>
<p>It should be noted that some routines may behave poorly or unpredictably when using 4-byte reals (libip_4). For instance, there is an ATAN2 function used for polar stereo grids where for certain grids/coordinates, floating point differences between 4-byte output values (~1e-7) can be amplified into noticeable differences in output field values. Some applications may therefore benefit from the use of 8-byte reals (libip_d).</p>
<h3><a class="anchor" id="autotoc_md2"></a>
Bilinear Interpolation</h3>
<p>Bilinear interpolation is chosen by setting IP=0.</p>
<p>This method has two sub-options:</p>
<ol type="1">
<li>The percent of valid input data required to make output data (the default is 50%).</li>
<li>If valid input data is not found near an a spiral search may be performed. The spiral search is only an option for scalar data.</li>
</ol>
<p>The bilinear method has no restrictions and can interpolate with bitmaps.</p>
<h3><a class="anchor" id="autotoc_md3"></a>
Bicubic Interpolation</h3>
<p>Bicubic interpolation is chosen by setting IP=1.</p>
<p>This method has two sub-options:</p>
<ol type="1">
<li>A monotonic constraint option for straight bicubic or for constraining the output value to be within the range of the four surrounding input values.</li>
<li>The percent of valid input data required to make output data, which defaults to 50%.</li>
</ol>
<p>The bicubic method cannot interpolate data with bitmaps.</p>
<h3><a class="anchor" id="autotoc_md4"></a>
Neighbor Interpolation</h3>
<p>Neighbor interpolation is chosen by setting IP=2.</p>
<p>Neighbor interpolation means that the output value is set to the nearest input value. It would be appropriate for interpolating integer fields such as vegetation index.</p>
<p>This method has one sub-option: If valid input data is not found near an an output point, a spiral search is optionally performed.</p>
<p>The neighbor method has no restrictions and can interpolate with bitmaps.</p>
<h3><a class="anchor" id="autotoc_md5"></a>
Budget interpolation</h3>
<p>Budget interpolation is chosen by setting IP=3.</p>
<p>Budget interpolation means a low-order interpolation method that quasi-conserves area averages. It would be appropriate for interpolating budget fields such as precipitation.</p>
<p>This method assumes that the field really represents box averages where each box extends halfway to its neighboring grid point in each direction. The method actually averages bilinearly interpolated values in a square array of points distributed within each output grid box.</p>
<p>There are several sub-options:</p>
<ol type="1">
<li>The number of points in the radius of the square array may be set. The default is 2, meaning that 25 sample points will be averaged for each output value.</li>
<li>The respective averaging weights for the radius points are adjustable. The default is for all weights equal to 1, giving an unweighted average.</li>
<li>Optionally, one may assume the boxes stretch nearly all the way to each of the neighboring grid points and the weights are the adjoint of the bilinear interpolation weights.</li>
<li>The percent of valid input data required to make output data is adjustable. The default is 50%.</li>
<li>In cases where there is no or insufficient valid input data, a spiral search may be invoked to search for the nearest valid data. search square (scalar interpolation only).</li>
</ol>
<p>This method can interpolate data with bitmaps.</p>
<h3><a class="anchor" id="autotoc_md6"></a>
Spectral Interpolation</h3>
<p>Spectral interpolation is chosen by setting IP=4.</p>
<p>This method has two sub-options:</p>
<ol type="1">
<li>set the spectral shape (triangular or rhomboidal)</li>
<li>set the spectral truncation.</li>
</ol>
<p>The input grid must be a global cylindrical grid (either Gaussian or equidistant). This method cannot interpolate data with bitmaps.</p>
<p>Unless the output grid is a global cylindrical grid, a polar stereographic grid centered at the pole, or a Mercator grid, this method can be quite expensive.</p>
<h3><a class="anchor" id="autotoc_md7"></a>
Neighbor-Budget Interpolation</h3>
<p>Neighbor-budget interpolation is chosen by setting IP=6.</p>
<p>This method computes weighted averages of neighbor points arranged in a square box centered around each output grid point and stretching nearly halfway to each of the neighboring grid points. The main difference with the budget interpolation (IP=3) is neighbor vs bilinear interpolation of the square box of points.</p>
<p>There are the following sub-options:</p>
<ol type="1">
<li>The number of points in the radius of the square array may be set. The default is 2, meaning that 25 sample points will be averaged for each output value.</li>
<li>The respective averaging weights for the radius points are adjustable. The default is for all weights equal to 1, giving an unweighted average.</li>
<li>The percent of valid input data required to make output data is adjustable. The default is 50%.</li>
</ol>
<h2><a class="anchor" id="autotoc_md8"></a>
Vectors and Scalars</h2>
<p>The library can handle two-dimensional vector fields as well as scalar fields. The input and output vectors are rotated if necessary so that they are either resolved relative to their defined grid in the direction of increasing x and y coordinates or resolved relative to eastward and northward directions on the earth. The rotation is determined by the grid definitions.</p>
<p>Vectors are generally interpolated (by all methods except spectral interpolation) by moving the relevant input vectors along a great circle to the output point, keeping their orientations with respect to the great circle constant, before independently interpolating the respective components. This ensures that vector interpolation will be consistent over the whole globe including the poles.</p>
<h2><a class="anchor" id="autotoc_md9"></a>
Grids</h2>
<p>The input and output grids are defined by their respective GRIB2 grid definition template and template number as decoced by the NCEP G2 library. There are six map projections recognized by the library:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Grid Template Number   </th><th class="markdownTableHeadNone">Map projection    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">00   </td><td class="markdownTableBodyNone">Equidistant cyclindrical    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">01   </td><td class="markdownTableBodyNone">Rotated equidistant cylindrical    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">10   </td><td class="markdownTableBodyNone">Mercator cyclindrical    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">20   </td><td class="markdownTableBodyNone">Polar stereographic azimuthal    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">30   </td><td class="markdownTableBodyNone">Lambert conformal conical    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">40   </td><td class="markdownTableBodyNone">Gaussian equidistant cyclindrical   </td></tr>
</table>
<p>If the output grid definition template number is negative, then the output data may be just a set of station points. In this case, the user must pass the number of points to be output along with their latitudes and longitudes.</p>
<p>For vector interpolation, the vector rotations parameters must also be passed. On the other hand, for non-negative output data representation types, the number of output grid points and their latitudes and longitudes (and the vector rotation parameters for vector interpolation) are all returned by the interpolation subprograms.</p>
<p>If an output equidistant cylindrical grid contains multiple pole points, then the pole points are forced to be self-consistent. That is, scalar fields are obliged to be constant at the pole and vector components are obliged to exhibit a wavenumber one variation at the pole.</p>
<p>Generally, only regular grids can be interpolated in this library. However, the thinned WAFS grids may be expanded to a regular grid (or vice versa) using subprograms <a class="el" href="ipxwafs_8F90.html#a1465ea191950f7464bb3374abed94c12" title="Expand or contract wafs grids.">ipxwafs()</a>, <a class="el" href="ipxwafs2_8F90.html#ab602c9c04957836c0b8860560d442894" title="Expand or contract wafs grids using linear interpolation and account for bitmapped data.">ipxwafs2()</a>, or <a class="el" href="ipxwafs3_8F90.html#aae7be3c77cbe16d0219c86e443e6ec1d" title="Expand or contract wafs grids using neighbor interpolation and accout for bitmapped data.">ipxwafs3()</a>. Eta data (with Arakawa "E" staggering) on the "H" or "V" grid may be expanded to a filled regular grid (or vice versa) using subprogram <a class="el" href="ipxetas_8F90.html#a89ff34ee39b0da1895e9d8552bb462e1" title="Expand or contract eta grids using linear interpolation.">ipxetas()</a>.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
Return Codes</h2>
<p>The return code issued by an interpolation subprogram determines whether it ran successfully or how it failed. Check nonzero return codes against the docblock of the respective subprogram.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Entry point list</h2>
<p>Scalar and vecotr field interpolation subprograms can be found in the relevant module documentation:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Function    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="namespaceipolates__mod.html" title="Top-level driver for scalar interpolation interpolation routine ipolates().">ipolates_mod</a>   </td><td class="markdownTableBodyNone">Iredell's polate    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="namespacebilinear__interp__mod.html" title="Bilinear interpolation routines for scalars and vectors.">bilinear_interp_mod</a>   </td><td class="markdownTableBodyNone">bilinear interpolation    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="namespacebicubic__interp__mod.html" title="Bicubic interpolation routines for scalars and vectors.">bicubic_interp_mod</a>   </td><td class="markdownTableBodyNone">bicubic interpolation    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="namespaceneighbor__interp__mod.html" title="Interpolate scalar fields (neighbor).">neighbor_interp_mod</a>   </td><td class="markdownTableBodyNone">neighbor interpolation    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="namespacebudget__interp__mod.html" title="Budget interpolation routines for scalars and vectors.">budget_interp_mod</a>   </td><td class="markdownTableBodyNone">budget interpolation    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="namespacespectral__interp__mod.html" title="Interpolate spectral.">spectral_interp_mod</a>   </td><td class="markdownTableBodyNone">spectral interpolation    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="namespaceneighbor__budget__interp__mod.html" title="Interpolate scalar fields (neighbor).">neighbor_budget_interp_mod</a>   </td><td class="markdownTableBodyNone">neighbor-budget interpolation    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="namespacepolfix__mod.html#a15df1ba2e1fcad1e9465c4aa3a2ba0d6" title="Make multiple pole scalar values consistent.">polfixs()</a>   </td><td class="markdownTableBodyNone">make multiple pole scalar values consistent    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="movect_8F90.html#a5974e32c0cf90a65b39c68460d761882" title="This subprogram provides the rotation parameters to move a vector along a great circle from one posit...">movect()</a>   </td><td class="markdownTableBodyNone">move a vector along a great circle    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="namespacepolfix__mod.html#aeefc8f045777f6d962d9ec539ef6007d" title="Make multiple pole vector values consistent,.">polfixv()</a>   </td><td class="markdownTableBodyNone">make multiple pole vector values consistent   </td></tr>
</table>
<p>Grid description section decoders:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Function    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="ip2lib__4_8h.html#a44daefd49c37e9bc59933d98e56efa53" title="gdswzd() interface for C for _4 build of library.">gdswzd()</a>   </td><td class="markdownTableBodyNone">grid description section (GDS) wizard    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="namespacegdswzd__c__mod.html#ae3026381f7f41561507c97c9125d24e4" title="C wrapper for routine gdswzd().">gdswzd_c()</a>   </td><td class="markdownTableBodyNone">C wrapper for calling gdswzd    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="namespaceip__equid__cylind__grid__mod.html#af20f6f308b5a33211c677b894e41b727" title="Calculates Earth coordinates (iopt = 1) or grid coorindates (iopt = -1) for equidistant cylindrical g...">gdswzd_equid_cylind()</a>   </td><td class="markdownTableBodyNone">GDS wizard for equidistant cyclindrical    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="namespaceip__mercator__grid__mod.html#acc39017fa51125972ab8e755e16d339e" title="GDS wizard for mercator cylindrical.">gdswzd_mercator()</a>   </td><td class="markdownTableBodyNone">GDS wizard for mercator cyclindrical    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="namespaceip__lambert__conf__grid__mod.html#a5ebb9e4f1bd58caa254771b305c94f71" title="GDS wizard for lambert conformal conical.">gdswzd_lambert_conf()</a>   </td><td class="markdownTableBodyNone">GDS wizard for lambert conformal conical    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="namespaceip__gaussian__grid__mod.html#a6eefd9270b3f9bb2c59a77bea4ecf1b9" title="Calculates Earth coordinates (iopt = 1) or grid coorindates (iopt = -1) for Gaussian grids.">gdswzd_gaussian()</a>   </td><td class="markdownTableBodyNone">GDS wizard for gaussian cyclindrical    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="namespaceip__polar__stereo__grid__mod.html#ae2694d90ab514a131e083dfba3b173c5" title="GDS wizard for polar stereographic azimuthal.">gdswzd_polar_stereo()</a>   </td><td class="markdownTableBodyNone">GDS wizard for polar stereographic    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="namespaceip__rot__equid__cylind__egrid__mod.html#a9ad11a599fc0bdc4a9ece86a3b1cc399" title="Calculates Earth coordinates (iopt = 1) or grid coorindates (iopt = -1) for rotated equidistant cylin...">gdswzd_rot_equid_cylind_egrid()</a>   </td><td class="markdownTableBodyNone">GDS wizard for rotated equidistant cyclindrical "e" stagger.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="namespaceip__rot__equid__cylind__grid__mod.html#a55c153201e15205d3f75e4ffb717cc0b" title="GDS wizard for rotated equidistant cylindrical.">gdswzd_rot_equid_cylind()</a>   </td><td class="markdownTableBodyNone">GDS wizard for rotated equidistant cyclindrical non "e" stagger.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="namespaceip__grid__mod.html#a63572318d74ec94c20c5ccd6ded2d442" title="Returns the field position for a given grid point.">field_pos()</a>   </td><td class="markdownTableBodyNone">return field position for a given grid point   </td></tr>
</table>
<p>Transform subprograms for special irregular grids:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Function    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="ipxwafs_8F90.html#a1465ea191950f7464bb3374abed94c12" title="Expand or contract wafs grids.">ipxwafs()</a>   </td><td class="markdownTableBodyNone">expand or contract wafs grids    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="ipxwafs2_8F90.html#ab602c9c04957836c0b8860560d442894" title="Expand or contract wafs grids using linear interpolation and account for bitmapped data.">ipxwafs2()</a>   </td><td class="markdownTableBodyNone">expand or contract wafs grids    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="ipxwafs3_8F90.html#aae7be3c77cbe16d0219c86e443e6ec1d" title="Expand or contract wafs grids using neighbor interpolation and accout for bitmapped data.">ipxwafs3()</a>   </td><td class="markdownTableBodyNone">expand or contract wafs grids   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md12"></a>
How to invoke ip2lib: examples</h2>
<pre>
***********************************************************************
Example 1. Read a grib 2 file of scalar data on a global regular
            1-deg lat/lon grid and call ipolates to interpolate
            it to NCEP standard grid 218, a lambert conformal grid.
            Uses the NCEP G2 library to degrib the data.
***********************************************************************

 program example_1

use <a class="el" href="namespaceip__mod.html" title="Top-level module for the ip library which re-exports public routines such as ipolates,...">ip_mod</a>
 use grib_mod  ! ncep grib 2 library

 implicit none

 character(len=100)      :: input_file

 integer                 :: iunit, iret, lugi
 integer                 :: mi, mo, no
 integer, allocatable    :: ibi(:), ibo(:)
 integer                 :: ip, ipopt(20)
 integer                 :: j, jdisc, jpdtn, jgdtn, k, km
 integer                 :: jids(200), jgdt(200), jpdt(200)
 integer                 :: idim_input, jdim_input
 integer                 :: idim_output, jdim_output

 logical                 :: unpack
 logical*1, allocatable  :: input_bitmap(:,:), output_bitmap(:,:)

 real, allocatable       :: input_data(:,:)
 real, allocatable       :: output_rlat(:), output_rlon(:)
 real, allocatable       :: output_data(:,:)

 type(gribfield)         :: gfld_input

!---------------------------------------------------------------------------
! the output grid specs. this is ncep grid 218, a lambert conformal
! grid. the grid definition information is stored in section 3
! of a grib 2 message.
!---------------------------------------------------------------------------

 integer, parameter :: igdtnum218 = 30 ! grid definition template number.
                                       ! "30" is lambert conformal.
 integer, parameter :: igdtlen218 = 22 ! number of array elements needed
                                       ! for a lambert conf. grid definition
                                       ! template.
 integer     :: igdtmpl218(igdtlen218) ! the grid definition template.
                                       ! the entries are:
                                       ! 1 -shape of earth, oct 15
                                       ! 2 -scale factor, spherical earth, oct 16
                                       ! 3 -scaled value, spherical earth, octs 17-20
                                       ! 4 -scale factor, major axis of
                                       !    elliptical earth, oct 21
                                       ! 5 -scaled value of major axis of
                                       !    elliptical earth, octs 22-25
                                       ! 6 -scale factor, minor axis of
                                       !    elliptical earth, oct 26
                                       ! 7 -scaled value of minor axis of
                                       !    elliptical earth, octs 27-30
                                       ! 8 -number points along x-axis, octs 31-34
                                       ! 9 -number points along y-axis, octs 35-38
                                       ! 10-latitude of first point, octs 39-42
                                       ! 11-longitude of first point, octs 43-46
                                       ! 12-resolution and component flags, oct 47
                                       ! 13-latitude where grid lengths specified, 
                                       !    octs 48-51
                                       ! 14-longitude parallel to y-axis, octs 52-55
                                       ! 15-x-direction grid length, octs 56-59
                                       ! 16-y-direction grid length, octs 60-63
                                       ! 17-projection center flag, oct 64
                                       ! 18-scanning mode, oct 65
                                       ! 19-first tangent latitude from pole, octs 66-69
                                       ! 20-second tangent latitude from pole, octs 70-73
                                       ! 21-latitude of south pole, octs 74-77
                                       ! 22-longitude of south pole, octs 78-81

 integer, parameter :: missing=b'11111111111111111111111111111111'
 data igdtmpl218 / 6, 255, missing, 255, missing, 255, missing, 614, 428, &amp;
                  12190000, 226541000, 56, 25000000, 265000000, &amp;
                  12191000, 12191000, 0, 64, 25000000, 25000000, -90000000, 0/

!---------------------------------------------------------------------------
! open the grib 2 file containing data to be interpolated. for this
! example, there are two data records.
!---------------------------------------------------------------------------

 iunit=9
 input_file="${path}/input.data.grib2"
 call baopenr (iunit, input_file, iret)

!---------------------------------------------------------------------------
! prep for call to g2 library to degrib data. the data are on a regular
! lat/lon grid with i/j dimension of 360/181. 
!---------------------------------------------------------------------------

 idim_input = 360  ! the i/j dimensions of input grid
 jdim_input = 181
 mi         = idim_input * jdim_input   ! total number of pts, input grid

 jdisc   = -1         ! search for any discipline
 jpdtn   = -1         ! search for any product definition template number
 jgdtn   =  0         ! search for grid definition template number 0 - regular lat/lon grid
 jids    = -9999      ! array of values in identification section, set to wildcard
 jgdt    = -9999      ! array of values in grid definition template 3.m
 jgdt(8) = idim_input ! search for grid with i/j of 360/181
 jgdt(9) = jdim_input
 jpdt    = -9999      ! array of values in product definition template 4.n
 unpack  = .true.     ! unpack data
 lugi    = 0          ! no index file

 nullify(gfld_inputidsect)
 nullify(gfld_inputlocal)
 nullify(gfld_inputlist_opt)
 nullify(gfld_inputigdtmpl)  ! holds the grid definition template information
 nullify(gfld_inputipdtmpl)
 nullify(gfld_inputcoord_list)
 nullify(gfld_inputidrtmpl)
 nullify(gfld_inputbmap)     ! holds the bitmap
 nullify(gfld_inputfld)      ! holds the data

!---------------------------------------------------------------------------
! degrib the data.  non-zero "iret" indicates a problem during degrib.
!---------------------------------------------------------------------------

 km = 2                  ! number of records to interpolate

 allocate(ibi(km))
 allocate(input_bitmap(mi,km))
 allocate(input_data(mi,km))

 do j = 0, (km-1)    ! number of records to skip

   call getgb2(iunit, lugi, j, jdisc, jids, jpdtn, jpdt, jgdtn, jgdt, &amp;
               unpack, k, gfld_input, iret)

   if (iret /= 0) stop

!---------------------------------------------------------------------------
! does input data have a bitmap?
!---------------------------------------------------------------------------

   if (gfld_inputibmap==0) then  ! input data has bitmap
     ibi(k)            = 1        ! tell ipolates to use bitmap
     input_bitmap(:,k) = gfld_inputbmap
   else                           ! no bitmap, data everywhere
     ibi(k)            = 0        ! tell ipolates there is no bitmap
     input_bitmap(:,k) = .true.
   endif

   input_data(:,k) = gfld_inputfld  ! the input data field

 enddo

 call baclose (iunit, iret)

!---------------------------------------------------------------------------
! setup arguments for ipolates (scalar interpolation) call.
!---------------------------------------------------------------------------

 ip       = 0                         ! bilinear interpolation
 ipopt    = 0                         ! options for bilinear:
 ipopt(1) = 75                        ! set minimum mask to 75%

!---------------------------------------------------------------------------
! the i/j dimensions of the output grid.
!---------------------------------------------------------------------------

 idim_output = igdtmpl218(8)
 jdim_output = igdtmpl218(9)
 mo          = idim_output * jdim_output ! total number of output pts

!---------------------------------------------------------------------------
! will hold the latitude, longitude, data and bitmap on the output grid,
! which are computed in ipolates.
!---------------------------------------------------------------------------

 allocate (ibo(km))              ! bitmap flags on output grid
 allocate (output_rlat(mo))
 allocate (output_rlon(mo))
 allocate (output_data(mo,km))
 allocate (output_bitmap(mo,km))

!---------------------------------------------------------------------------
! call ipolates to interpolate scalar data.  non-zero "iret" indicates
! a problem.
!---------------------------------------------------------------------------

 call ipolates(ip, ipopt, gfld_inputigdtnum, gfld_inputigdtmpl, &amp;
               gfld_inputigdtlen, igdtnum218, igdtmpl218, igdtlen218, &amp;
               mi, mo, km, ibi, input_bitmap, input_data, no, output_rlat, &amp;
               output_rlon, ibo, output_bitmap, output_data, iret)

 if (iret /= 0) stop

!---------------------------------------------------------------------------
! write interpolated data to file.  if ipolates computed a bitmap (ibo==1) 
! for the output grid, one may mask out this data with a flag value.
!---------------------------------------------------------------------------

 open (10, file="./output.bin", access='direct', recl=idim_output*jdim_output*4)

 do k = 1, km
   if(ibo(k)==1) where (.not. output_bitmap(:,k)) output_data(:,k) = -999.
   write(10, rec=k) output_data(:,k)
 enddo
 write(10, rec=km+1) output_rlat
 write(10, rec=km+2) output_rlon

 close(10)

 end program example_1

***********************************************************************
Example 2.  Read a grib 2 file of u/v wind data on a global regular
            1-deg lat/lon grid and call ipolatev to interpolate
            it to four random station points.  Uses the NCEP
            G2 library to degrib the data.
***********************************************************************

 program example_2

 use grib_mod  ! ncep grib 2 library

 implicit none

 character(len=100)      :: input_file

 integer                 :: iunit, iret, lugi
 integer                 :: mi, mo, no
 integer                 :: ibi, ibo
 integer                 :: ip, ipopt(20)
 integer                 :: j, jdisc, jpdtn, jgdtn, k, km
 integer                 :: jids(200), jgdt(200), jpdt(200)
 integer                 :: idim_input, jdim_input

 logical                 :: unpack
 logical*1, allocatable  :: input_bitmap(:), output_bitmap(:)

 real, allocatable       :: input_u_data(:), input_v_data(:)
 real, allocatable       :: output_rlat(:), output_rlon(:)
 real, allocatable       :: output_crot(:), output_srot(:)
 real, allocatable       :: output_u_data(:), output_v_data(:)

 type(gribfield)         :: gfld_input

!---------------------------------------------------------------------------
! the output "grid" is a series of random station points.  in this case,
! set the grid definition template number of a negative number.
! the grid definition template array information is not used, so set
! to a flag value.
!---------------------------------------------------------------------------

 integer, parameter      :: igdtnumo = -1 
 integer, parameter      :: igdtleno =  1
 integer                 :: igdtmplo(igdtleno)

 data igdtmplo / -9999 /

!---------------------------------------------------------------------------
! open the grib 2 file containing data to be interpolated.  for this
! example, there is one record of u-wind and v-wind.
!---------------------------------------------------------------------------

 iunit=9
 input_file="./reg_tests/copygb2/data/uv_wind.grb2"
 call baopenr (iunit, input_file, iret)

!---------------------------------------------------------------------------
! prep for call to g2 library to degrib data. the data are on a regular
! lat/lon grid with i/j dimension of 360/181.  
!---------------------------------------------------------------------------

 idim_input = 360  ! the i/j dimensions of input grid
 jdim_input = 181
 mi         = idim_input * jdim_input   ! total number of pts, input grid

 jdisc   = -1         ! search for any discipline
 jpdtn   = -1         ! search for any product definition template number
 jgdtn   =  0         ! search for grid definition template number 0 - regular lat/lon grid
 jids    = -9999      ! array of values in identification section, set to wildcard
 jgdt    = -9999      ! array of values in grid definition template 3.m
 jgdt(8) = idim_input ! search for grid with i/j of 360/181
 jgdt(9) = jdim_input
 jpdt    = -9999      ! array of values in product definition template 4.n
 unpack  = .true.     ! unpack data
 lugi    = 0          ! no index file

 nullify(gfld_inputidsect)
 nullify(gfld_inputlocal)
 nullify(gfld_inputlist_opt)
 nullify(gfld_inputigdtmpl)  ! holds the grid definition template information
 nullify(gfld_inputipdtmpl)
 nullify(gfld_inputcoord_list)
 nullify(gfld_inputidrtmpl)
 nullify(gfld_inputbmap)     ! holds the bitmap
 nullify(gfld_inputfld)      ! holds the data

!---------------------------------------------------------------------------
! degrib the data.  non-zero "iret" indicates a problem during degrib.
!---------------------------------------------------------------------------

 allocate(input_bitmap(mi))
 allocate(input_u_data(mi))
 allocate(input_v_data(mi))

!---------------------------------------------------------------------------
! read u-wind record.
!---------------------------------------------------------------------------

 j = 0
 call getgb2(iunit, lugi, j, jdisc, jids, jpdtn, jpdt, jgdtn, jgdt, &amp;
             unpack, k, gfld_input, iret)

 if (iret /= 0) stop

!---------------------------------------------------------------------------
! does input data have a bitmap?
!---------------------------------------------------------------------------

 if (gfld_inputibmap==0) then  ! input data has bitmap
   ibi          = 1             ! tell ipolates to use bitmap
   input_bitmap = gfld_inputbmap
 else                           ! no bitmap, data everywhere
   ibi          = 0             ! tell ipolates there is no bitmap
   input_bitmap = .true.
 endif

 input_u_data = gfld_inputfld  ! the input u-wind data

!---------------------------------------------------------------------------
! read v-wind record.
!---------------------------------------------------------------------------

 j = 1
 call getgb2(iunit, lugi, j, jdisc, jids, jpdtn, jpdt, jgdtn, jgdt, &amp;
             unpack, k, gfld_input, iret)

 if (iret /= 0) stop

 input_v_data = gfld_inputfld  ! the input v-wind data

 call baclose (iunit, iret)

!---------------------------------------------------------------------------
! setup arguments for ipolatev (vector interpolation) call.
!---------------------------------------------------------------------------

 km       = 1                         ! number of records to interpolate
 ip       = 0                         ! bilinear interpolation
 ipopt    = 0                         ! options for bilinear:
 ipopt(1) = 75                        ! set minimum mask to 75%

!---------------------------------------------------------------------------
! interpolate to four random station points.
!---------------------------------------------------------------------------

 mo = 4
 no = mo

!---------------------------------------------------------------------------
! when interpolating to random station points, need to pass to ipolatev
! their latitude, longitude and the sines and cosines of the vector
! rotation angles.  the vector rotation is defined:
!
! ugrid=crot*uearth-sort*vearth
! vgrid=srot*uearth+cort*vearth
!---------------------------------------------------------------------------

 allocate (output_rlat(mo))
 allocate (output_rlon(mo))
 allocate (output_srot(mo))
 allocate (output_crot(mo))
 allocate (output_u_data(mo))
 allocate (output_v_data(mo))
 allocate (output_bitmap(mo))

 output_rlat(1) = 45.0
 output_rlon(1) = -100.0
 output_rlat(2) = 35.0
 output_rlon(2) = -100.0
 output_rlat(3) = 40.0
 output_rlon(3) = -90.0
 output_rlat(4) = 35.0
 output_rlon(4) = -120.0

 output_srot = 0.0   ! no turning of wind
 output_crot = 1.0

!---------------------------------------------------------------------------
! call ipolatev to interpolate vector data.  non-zero "iret" indicates
! a problem.
!---------------------------------------------------------------------------

 call ipolatev(ip, ipopt, gfld_inputigdtnum, gfld_inputigdtmpl, &amp;
               gfld_inputigdtlen, igdtnumo, igdtmplo, igdtleno, &amp;
               mi, mo, km, ibi, input_bitmap, input_u_data, input_v_data, &amp;
               no, output_rlat, output_rlon, output_crot, output_srot, &amp;
               ibo, output_bitmap, output_u_data, output_v_data, iret)

 if (iret /= 0) stop

 do k = 1, mo
   print*,'station point ',k,' latitude ',output_rlat(k),' longitude ', &amp;
   output_rlon(k), ' u-wind ', output_u_data(k), ' v-wind ', output_v_data(k)
 enddo

 end program example_2
</pre> </div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
